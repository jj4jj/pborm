#pragma once

//this file is auto generated by (hbpex)[https://github.com/jj4jj/hpbex.git] , don't edit this file !
//file generate datetime: Wed Dec 16 20:15:26 2015

#include <algorithm>
#include "pborm_conf.pb.h"

namespace pborm { 


struct ProcessConf_ST {
    struct { char data[32]; }		pidfile;
    uint32_t		daemon;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        pidfile.data[0] = 0;
        daemon = 0;
    }
    void		convto(ProcessConf & convtomsg_) const {
        convtomsg_.set_pidfile(pidfile.data);
        convtomsg_.set_daemon(daemon);
    }
    void		convfrom(const ProcessConf & convfrommsg_) {
        strncpy(pidfile.data, convfrommsg_.pidfile().data(), 32-1);
        daemon = convfrommsg_.daemon();
    }
    int		compare(const ProcessConf_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = strncmp(pidfile.data, rhs_.pidfile.data, 32);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = (daemon < rhs_.daemon) ? -1 : ((daemon == rhs_.daemon) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const ProcessConf_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const ProcessConf_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct DBConf_ST {
    struct { char data[32]; }		ip;
    uint32_t		port;
    struct { char data[64]; }		sock;
    uint32_t		reconnect;
    struct { char data[8]; }		charset;
    uint32_t		autocommit;
    struct { char data[16]; }		uname;
    struct { char data[16]; }		passwd;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        ip.data[0] = 0;
        port = 0;
        sock.data[0] = 0;
        reconnect = 0;
        charset.data[0] = 0;
        autocommit = 0;
        uname.data[0] = 0;
        passwd.data[0] = 0;
    }
    void		convto(DBConf & convtomsg_) const {
        convtomsg_.set_ip(ip.data);
        convtomsg_.set_port(port);
        convtomsg_.set_sock(sock.data);
        convtomsg_.set_reconnect(reconnect);
        convtomsg_.set_charset(charset.data);
        convtomsg_.set_autocommit(autocommit);
        convtomsg_.set_uname(uname.data);
        convtomsg_.set_passwd(passwd.data);
    }
    void		convfrom(const DBConf & convfrommsg_) {
        strncpy(ip.data, convfrommsg_.ip().data(), 32-1);
        port = convfrommsg_.port();
        strncpy(sock.data, convfrommsg_.sock().data(), 64-1);
        reconnect = convfrommsg_.reconnect();
        strncpy(charset.data, convfrommsg_.charset().data(), 8-1);
        autocommit = convfrommsg_.autocommit();
        strncpy(uname.data, convfrommsg_.uname().data(), 16-1);
        strncpy(passwd.data, convfrommsg_.passwd().data(), 16-1);
    }
    int		compare(const DBConf_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = strncmp(ip.data, rhs_.ip.data, 32);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = (port < rhs_.port) ? -1 : ((port == rhs_.port) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = strncmp(sock.data, rhs_.sock.data, 64);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = (reconnect < rhs_.reconnect) ? -1 : ((reconnect == rhs_.reconnect) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = strncmp(charset.data, rhs_.charset.data, 8);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = (autocommit < rhs_.autocommit) ? -1 : ((autocommit == rhs_.autocommit) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = strncmp(uname.data, rhs_.uname.data, 16);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = strncmp(passwd.data, rhs_.passwd.data, 16);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const DBConf_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const DBConf_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct LogConf_ST {
    struct { char data[128]; }		path;
    struct { char data[8]; }		level;
    struct { char data[32]; }		file_pattern;
    uint32_t		max_roll;
    uint32_t		max_file_size;
    uint32_t		max_line_size;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        path.data[0] = 0;
        level.data[0] = 0;
        file_pattern.data[0] = 0;
        max_roll = 0;
        max_file_size = 0;
        max_line_size = 0;
    }
    void		convto(LogConf & convtomsg_) const {
        convtomsg_.set_path(path.data);
        convtomsg_.set_level(level.data);
        convtomsg_.set_file_pattern(file_pattern.data);
        convtomsg_.set_max_roll(max_roll);
        convtomsg_.set_max_file_size(max_file_size);
        convtomsg_.set_max_line_size(max_line_size);
    }
    void		convfrom(const LogConf & convfrommsg_) {
        strncpy(path.data, convfrommsg_.path().data(), 128-1);
        strncpy(level.data, convfrommsg_.level().data(), 8-1);
        strncpy(file_pattern.data, convfrommsg_.file_pattern().data(), 32-1);
        max_roll = convfrommsg_.max_roll();
        max_file_size = convfrommsg_.max_file_size();
        max_line_size = convfrommsg_.max_line_size();
    }
    int		compare(const LogConf_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = strncmp(path.data, rhs_.path.data, 128);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = strncmp(level.data, rhs_.level.data, 8);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = strncmp(file_pattern.data, rhs_.file_pattern.data, 32);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = (max_roll < rhs_.max_roll) ? -1 : ((max_roll == rhs_.max_roll) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = (max_file_size < rhs_.max_file_size) ? -1 : ((max_file_size == rhs_.max_file_size) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = (max_line_size < rhs_.max_line_size) ? -1 : ((max_line_size == rhs_.max_line_size) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const LogConf_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const LogConf_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};
struct Config_ST {
    LogConf_ST		log;
    DBConf_ST		db;
    ProcessConf_ST		process;
    struct { char data[64]; }		meta_path;
    uint32_t		thread_num;
    struct { char data[64]; }		listen;
    	
    //////////////member functions///////////////////////////////////
    void		construct() {
        if(sizeof(*this) < 1024) { memset(this,0,sizeof(*this)); return ;}
        log.construct();
        db.construct();
        process.construct();
        meta_path.data[0] = 0;
        thread_num = 0;
        listen.data[0] = 0;
    }
    void		convto(Config & convtomsg_) const {
        log.convto(*convtomsg_.mutable_log());
        db.convto(*convtomsg_.mutable_db());
        process.convto(*convtomsg_.mutable_process());
        convtomsg_.set_meta_path(meta_path.data);
        convtomsg_.set_thread_num(thread_num);
        convtomsg_.set_listen(listen.data);
    }
    void		convfrom(const Config & convfrommsg_) {
        log.convfrom(convfrommsg_.log());
        db.convfrom(convfrommsg_.db());
        process.convfrom(convfrommsg_.process());
        strncpy(meta_path.data, convfrommsg_.meta_path().data(), 64-1);
        thread_num = convfrommsg_.thread_num();
        strncpy(listen.data, convfrommsg_.listen().data(), 64-1);
    }
    int		compare(const Config_ST & rhs_) const {
        int _cmp_ret = 0;
        _cmp_ret = log.compare(rhs_.log);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = db.compare(rhs_.db);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = process.compare(rhs_.process);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = strncmp(meta_path.data, rhs_.meta_path.data, 64);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = (thread_num < rhs_.thread_num) ? -1 : ((thread_num == rhs_.thread_num) ? 0 : 1);
        if (_cmp_ret != 0) { return _cmp_ret; }
        _cmp_ret = strncmp(listen.data, rhs_.listen.data, 64);
        if (_cmp_ret != 0) { return _cmp_ret; }
        return 0;
    }
    bool		operator == (const Config_ST & rhs_) const {
        return this->compare(rhs_) == 0;
    }
    bool		operator < (const Config_ST & rhs_) const {
        return this->compare(rhs_) < 0;
    }
};

} // end of namespace: pborm

